# BFS

[参考链接](https://blog.csdn.net/yuxuan20062007/article/details/83450657)

## 分支限界法
    类似与回溯法，也是一种在问题的解空间树T上搜索问题解的算法，但在一般情况下，分支限界法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

## 一般过程
    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树

    分支限定法的搜索策略：在扩展节点处，先生成其所有的儿子结点(分支)，然后再从当前的活结点表中选择下一个扩展对点。为了有效的选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值(限界)，并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找到一个最优解

    分支限定法常以广度优先或以最小消耗(最大效益)优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或结点表为空时为止。

## 回溯法和分支限界法的区别
- 回溯法
    
    深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足条件的所有解

- 分支限界法
    
    广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会，找出满足约束条件的一个解或特定意义下的最优解

## 常见的两种分支限界法
- 队列式
    
    按照队列先进先出原则选取下一个结点为扩展结点

- 优先队列式

    按照优先队列中规定的优先级选取最高的结点成为当前扩展结点

## 算法框架

```cpp
    void priority_bfs() 
    {
        priority_queue<Node> q;

        while(!q.empty())
        {
            livenode = q.top()
            q.pop();

            if () //判断是否更新最优解
            {
                //更新，记录最优解
            }

            搜索拓展结点的所有分支；

            定义新结点 newnode；
            q.push(newnode);
        }

        返回最优解；
    }

```

## 典型应用
    - 旅行商问题
    - 0-1背包问题

## 回溯和分支限界法的异同
    - 1 相同点
        - 均需要先定义问题的解空间，确定的解空间组织结构一般是树或图
        - 在问题的解空间树上搜索问题解
        - 搜索前均需要确定判定条件，该判断条件用于判断扩展生成的结点是否为可行结点
        - 搜索过程中必须判断扩展生成的结点是否满足判断条件，如果满足，则保留该扩展生成的结点，否则舍弃

    - 2 不同点
        - 搜索目标不同
        回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标是找出满足约束条件的一个解，或者在满足约束条件的解中找出某种意义下的最优解
        - 搜索方式不同
        DFS vs BFS或最小耗费优先
        - 扩展方式不同
        回溯法每次扩展一个孩子结点，分支限界法扩展结点生成所有的孩子结点