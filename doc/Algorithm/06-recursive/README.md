# Recursive

[参考链接](https://www.cnblogs.com/bakari/p/5349383.html)

## 递归的思想
    递归的思想是把问题分解成规模更小但和原问题有相同解法的思想
    - 问题能够分解为更小的规模，且与原问题有着相同的规模
    - 存在一个能让递归调用退出的简单出口

## 递归的效率
    1. 每次递归调用，需要保存当前上下文，在递归返回时需要恢复上下文
    2. 上下文包含：寄存器，局部变量，形参，函数地址等

    当堆栈规模过大时，将会导致栈溢出

    因此可以将递归转换成： 尾递归或非递归的模式

## 尾递归

    递归的调用存在函数的最后一步，且为唯一的一步，可以保证递归的效率，与非递归效率相当

## 递归转非递归
    递归转非递归一般分两种情况：
    - 1. 可以转为尾递归的，不用借助额外的栈结构将递归转化为循环结构
    - 2. 借助栈结构将递归转化为非递归

## 算法框架
    ```cpp
        while(栈不空){
            //标记当前结点可用
                v[i][j] = 1

            if(栈顶元素满足成功获取一条路径)
                pop()

            //依次将符合条件的当前结点的后继结点压入堆栈
            for(所有后继结点)
            {
                if (后继结点满足需求)
                    push(下一个结点)
            }

            if (没有符合条件的后继结点)
            {
                pop()

                //恢复当前结点为不可用
                v[i][j] = 0
            }
        }
    ```